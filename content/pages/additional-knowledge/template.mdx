---
title: "JavaScript - 额外解读"
date: "2021-02-01"
featured: false
category: "resource"
excerpt: ""
tag: ["iv"]
status: "publish"
type: "post"
cover: "./cover.png"
---


## JavaScript 起源

在了解、学习一个东西时，了解其诞生的背景及历史是十分有必要的，这能让你多一个发展的维度去看待它。

布兰登·艾奇（Bremdan Eich），在 1995 年受聘于网景（Netscape）公司。当时网景公司急需一种网页脚本语言，使得浏览器可以与网页互动，Eich 用了 10 天的时间创造了 Javascript。

那 10 天 Eich 做的大概事情可以在 Brendan Eich - JavaScript at 20 9:55 秒的时候看到。

总的来说他的设计思路是这样的

1. 借鉴 C 语言的基本语法；
2. 借鉴 Java 语言的数据类型和内存管理；
3. 借鉴 Scheme 语言，将函数提升到"第一等公民"（first class）的地位；
4. 借鉴 Self 语言，使用基于原型（prototype）的继承机制。

Eich 说，JavaScript 是 C 语言和 Self 语言的结合，我想无论怎样 JavaScript 都难以摆脱它们的影子。

在 Brendan Eich 2008 年的自述 中，发现一句话

Yet here we are. The web must evolve, or die. So too with JS.

世界总是在变的，Flash 会被淘汰，IE6 也终于退休。短短 20 年，JavaScript 的分支也变得十分庞大起来，我们面临权衡抉择，选择适合自己的技能树 evolve, or die。

下一章开始，让我们直接上干货。

---

## JavaScript 语法解析、AST、V8、JIT

### JavaScript 是如何执行的
对于常见编译型语言（例如：Java）来说，编译步骤分为：词法分析->语法分析->语义检查->代码优化和字节码生成。

对于解释型语言（例如 JavaScript）来说，通过词法分析 -> 语法分析 -> 语法树，就可以开始解释执行了。

![](https://cheogo.github.io/learn-javascript/assets/2017_09_01.png)

具体过程是这样的：

1.词法分析是将字符流(char stream)转换为记号流(token stream)
```txt
NAME "AST"  
EQUALS  
NAME "is Tree"  
SEMICOLON
```
2.语法分析成 AST (Abstract Syntax Tree)，你可以在这里试试 http://esprima.org/

3.预编译，当JavaScript引擎解析脚本时，它会在预编译期对所有声明的变量和函数进行处理！并且是先预声明变量，再预定义函数！

4.解释执行，在执行过程中，JavaScript 引擎是严格按着作用域机制（scope）来执行的，并且 JavaScript 的变量和函数作用域是在定义时决定的，而不是执行时决定的。JavaScript 中的变量作用域在函数体内有效，无块作用域；
```js
function func(){
    for(var i = 0; i < array.length; i++){  
      //do something here.  
    }
    //此时 i 仍然有值，及 i == array.length  
    console.log(i); // 但在 java 语言中，则无效
}
```
JavaScript 引擎通过作用域链（scope chain）把多个嵌套的作用域串连在一起，并借助这个链条帮助 JavaScript 解释器检索变量的值。这个作用域链相当于一个索引表，并通过编号来存储它们的嵌套关系。当 JavaScript 解释器检索变量的值，会按着这个索引编号进行快速查找，直到找到全局对象（global object）为止，如果没有找到值，则传递一个特殊的 undefined 值。
```js
var scope = "global";
scopeTest();
function scopeTest(){  
    console.log(scope);  
    var scope = "local";  
    console.log(scope); 
}
```
打印结果：undefined，local；

### V8、JIT
我们常说的 V8 是 Google 发布的开源 JavaScript 引擎，采用 C++ 编写。SpiderMonkey（Mozilla，基于 C）、Rhino（Mozilla，基于 Java），而 Nodejs 依赖于 V8 引擎开发，接下来的内容是 JavaScript 在 V8 引擎中的运行状态，而类似的 JavaScript 现代引擎对于这些实现大同小异。

在本文的开头提到了编译型语言，解释型语言。JavaScript 是解释型语言且弱类型，在生成 AST 之后，就开始一边解释，一边执行，但是有个弊端，当某段代码被多次执行时，它就有了可优化的空间（比如类型判断优化），而不用一次次的去重复之前的解释执行。 编译型语言如 JAVA，可以在执行前就进行优化编译，但是这会耗费大量的时间，显然不适用于 Web 交互。

于是就有了，JIT（Just-in-time），JIT 是两种模式的混合。



它是如何工作的呢：

1.在 JavaScript 引擎中增加一个监视器（也叫分析器）。监视器监控着代码的运行情况，记录代码一共运行了多少次、如何运行的等信息，如果同一行代码运行了几次，这个代码段就被标记成了 “warm”，如果运行了很多次，则被标记成 “hot”。

2.（基线编译器）如果一段代码变成了 “warm”，那么 JIT 就把它送到基线编译器去编译，并且把编译结果存储起来。比如，监视器监视到了，某行、某个变量执行同样的代码、使用了同样的变量类型，那么就会把编译后的版本，替换这一行代码的执行，并且存储。

3.（优化编译器）如果一个代码段变得 “hot”，监视器会把它发送到优化编译器中。生成一个更快速和高效的代码版本出来，并且存储。例如：循环加一个对象属性时，假设它是 INT 类型，优先做 INT 类型的判断

4.（去优化）可是对于 JavaScript 从来就没有确定这么一说，前 99 个对象属性保持着 INT 类型，可能第 100 个就没有这个属性了，那么这时候 JIT 会认为做了一个错误的假设，并且把优化代码丢掉，执行过程将会回到解释器或者基线编译器，这一过程叫做去优化。

优化代码图例：
“hot” 代码
![](https://cheogo.github.io/learn-javascript/assets/2017_09_03.jpg)


优化前
![](https://cheogo.github.io/learn-javascript/assets/2017_09_04.jpg)


优化后
![](https://cheogo.github.io/learn-javascript/assets/2017_09_05.jpg)


总结
明白一些基本原理能拓展出更多的东西，比如：

1.var a = 10; var b = 20; ==> var a=10, b=20; 这些改代码的好处是什么，如何从原理解释？
2.JavaScript 的函数和变量是在什么时候声明的，函数声明和函数表达式的区别？
3.如何通过编译器的优化原理，如何提高 JavaScript 的执行效率？

---

## Event Loop

本文以 Node.js 为例，讲解 Event Loop 在 Node.js 的实现，原文，JavaScript 中的实现大同小异。

### 什么是 Event Loop ？
单线程的 Node.js 能够实现无阻塞IO的原因就是事件循环（Event Loop）。

现在大多数系统内核是多线程的，所以它们可以在后台执行多个操作，当这些操作完成时，内核就会通知 Node.js，而这些操作的回调函数被添加到事件轮询列表（poll queue），并且 Node.js 会在适当的时机执行回调函数。

### 概览 Event Loop
当 Node.js 开始执行时，便初始化 Event Loop，执行过程中会存在许多异步操作，如：REPL、定时器（timers）、调用异步 API（请求，事件监听），在主进程代码执行完后，便开始运行 Event Loop。

下图描述了 Event Loop 中的各个阶段
```txt
   ┌───────────────────────┐
┌─>│        timers         │ 这个阶段执行 `setTimeout()` 和 `setInterval()` 中的回调函数
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
│  │     I/O callbacks     │ 这个阶段执行除了 `close` 回调函数以外的几乎所有的 I/0 回调函数
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
│  │     idle, prepare     │ 这个阶段仅仅 Node.js 内部使用
│  └──────────┬────────────┘      ┌───────────────┐
│  ┌──────────┴────────────┐      │   incoming:   │
│  │         poll          │<─────┤  connections, │ 执行队列中的回调函数、检索新的回调函数
│  └──────────┬────────────┘      │   data, etc.  │
│  ┌──────────┴────────────┐      └───────────────┘
│  │        check          │ `setImmediate()` 将在这里被调用
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
└──┤    close callbacks    │ `close` 回调函数被调用如：socket.on('close', ...)
   └───────────────────────┘
```

### 详解 Event Loop 的各个阶段

#### timers
setTimeout() 和 setInterval() 都要指定一个运行时间，这个运行时间其实不是确切的运行时间，而是一个期望时间，Event Loop 会在 timers 阶段执行超过期望时间的定时器回调函数，但由于你不确定在其他阶段甚至主进程中的事件执行时间，所以定时器不一定会按时执行。

```js
var asyncApi = function (callback) {
  setTimeout(callback, 90)
}

const timeoutScheduled = Date.now();
setTimeout(() => {
  const delay = Date.now() - timeoutScheduled;
  console.log(`${delay}ms setTimeout 被执行`); // 140ms 之后被执行
}, 100);

asyncApi(() => {
  const startCallback = Date.now();
  while (Date.now() - startCallback < 50) {
    // do nothing
  }
})
```

#### I/O callbacks
这个阶段主要执行一些系统操作带来的回调函数，如 TCP 错误，如果 TCP 尝试链接时出现 ECONNREFUSED 错误 ，一些 *nix 会把这个错误报告给 Node.js。而这个错误报告会先进入队列中，然后在 I/O callbacks 阶段执行。

#### poll
poll 阶段有两个主要功能：

也会执行时间定时器到达期望时间的回调函数
执行事件循环列表（poll queue）里的函数
当 Event Loop 进入 poll 阶段并且没有其余的定时器，那么：

如果事件循环列表不为空，则迭代同步的执行队列中的函数。
如果事件循环列表为空，则判断是否有 `setImmediate()` 函数待执行。如果有结束 poll 阶段，直接到 check 阶段。如果没有，则等待回调函数进入队列并立即执行。
#### check
在 poll 阶段结束之后，执行 `setImmediate()`。

#### close
突然结束的事件的回调函数会在这里触发，如果 `socket.destroy()`，那么 close 会被触发在这个阶段，也有可能通过 `process.nextTick()` 来触发。

#### setImmediate | setTimeout | process.nextTick
这里要说明一下 process.nextTick() 是在下次事件循环之前运行，如果把 `process.nextTick()` 和 `setImmediate()` 写在一起，那么是 `process.nextTick()` 先执行。next 比 immediate 快，官方也说这个函数命名有问题，但是因为历史存留没办法解决。
```js
process.nextTick(() => {
  console.log('nextTick');
});
setImmediate(() => {
  console.log('setImmediate');
});
setTimeout(() => {
  console.log('setTimeout'); 
}, 0)

// 执行结果，nextTick, setTimeout, setImmediate
// 查看 Node.js 源码，setTimeout(fun, 0) 会转化成 setTimeout(fun, 1)，所以在这种简单的情况下，对于不同设备，setImmediate 有可能早于 setTimeout 执行。
```
#### 总结
理解事件循环，会知道 JavaScript 如何无阻塞运行的，以及它简洁的开发思路和事件驱动风格。

---


## JavaScript 内存管理

JavaScript 具有垃圾自动回收机制（Garbage Collection）简称 GC。垃圾回收机制会中断整个代码执行，释放不可能再被使用的变量，释放内存，这个工作机制是周期性的，我们会在下文详细探讨。

可释放对象
```js
function fn1() {
  var obj1 = { name: 'xiaomuchen', age: '20' }
}
function fn2() {
  var obj2 = { name: 'xiaomuchen', age: '20' }
  return obj2
}
var a = fn1()
var b = fn2()
console.log(a, b) // undefined, {name: "xiaomuchen", age: "20"}
```
我们对比上面两个函数，fn1 在函数内声明变量 obj1 并且赋值，在函数执行后这个变量便不可再访问了，fn2 在最后把函数内的变量 obj2 返回到全局变量 b，所以 { name: 'xiaomuchen', age: '20' } 这个对象（或者说 obj2）依然可被访问。

JavaScript 回收机制通过判断变量是否可被访问，来决定回收哪些变量。

标记清除和引用计数
那么 JavaScript 是如何判断变量是否可被访问？这就要提到标记清除和引用计数。

标记清除：标记清除是目前大部分 JavaScript 引擎使用的判断方式，通过标记变量的状态来确定是否可被回收。当变量在环境中被声明时标记进入环境，理论上永远不要释放进入环境的变量，因为它可以在环境中的任何位置、任何时刻被访问。当环境被销毁（如函数执行完），则变量被标记离开环境等待回收。
```js
function fn(){
  var a = { count: 10 } // 被标记，进入环境 
  var b = { count: 20 } // 被标记，进入环境
}
fn(); // 执行完毕之后 b 被标记，离开环境
```

引用计数：JavaScript 引擎维护一张引用表，保存内存中所有的资源的引用次数。资源被引用一次则引用 +1，资源被去掉引用或者退出变量的函数作用域时，则引用 -1，当资源的引用次数为0时，说明无法访问这个值，则等待回收。 （注：引用计数从 1 到 0 这个过程可能不执行，而是直接标记可被回收，不再进行加减运算节约开销）
```js
function fn(){
  var a = { count: 10 } // 资源 { count: 10 } 被引用次数为 1
  a = { count: 20 } // 资源 { count: 20 } 被引用次数为 1，资源 { count: 10 } 被引用次数为 0，等待回收
  // do someThing
}
fn(); // 资源 { count: 20 } 被释放
```
但是引用计数存在一种循环引用的情况，如下例子，两个对象之间相互引用，在离开环境后对象不可访问，但由于对象的引用次数为 1，则导致不会被回收。这个例子来自《JavaScript 高级程序设计》，但我思考良久，如果引用计数把 a.param 也作为一个变量来计数，那么就没有这个问题了，引用计数实现的方式不同，产生的结果也不一样。
```js
function fn(){
  var a = { count: 10 }
  var b = { count: 20 }
  a.param = b // b 的引用次数为 2
  b.param = a // a 的引用次数为 2
}
fn(); // a、b 的引用次数为 1
```
GC 的缺陷、分代回收和增量 GC
和其他语言一样 GC 会中断代码执行，停止其他操作。因为要遍历所有对象，回收所有不可访问对象，这个操作的耗时可能有 100ms 以上。在 V8 引擎新版本中引入了两种优化方法：1. 分代回收（Generation GC），2. 增量 GC（increment GC）

分代回收：目的是通过对象的使用频率、存在时长区分新生代与老生代对象。多回收新生代区（young generation），少回收老生代区（tenured generation），减少每次需遍历的对象，从而减少每次GC的耗时

增量 GC：把需要长耗时的遍历、回收操作拆分运行，减少中断时间，但是会增大上下文切换开销

Node.js 中的 GC 表现
当我们用 Node.js 搭建一个稳定的服务时，就需要考虑服务器内存的开销，下面一个 Node.js 内存回收执行的例子：

执行代码node --trace_gc --trace_gc_verbose test.js跟踪一个网络服务的 GC。
```txt
[41204:0x102001c00] Memory reducer: call rate 0.056, low alloc, foreground
[41204:0x102001c00] Memory reducer: started GC #1
[41204:0x102001c00] Heap growing factor 1.1 based on mu=0.970, speed_ratio=42956 (gc=675253, mutator=16)
[41204:0x102001c00] Grow: old size: 21382 KB, new limit: 33604 KB (1.1)
[41204:0x102001c00] Memory reducer: finished GC #1 (will do more)
[41204:0x102001c00]   156410 ms: Mark-sweep 27.7 (50.0) -> 21.0 (30.0) MB, 12.4 / 0.0 ms (+ 20.4 ms in 7 steps since start of marking, biggest step 4.8 ms) [Incremental marking task: finalize incremental marking] [GC in old space requested].
[41204:0x102001c00] Memory allocator,   used:  30756 KB, available: 1435612 KB
[41204:0x102001c00] New space,          used:    169 KB, available:    838 KB, committed:   1024 KB
[41204:0x102001c00] Old space,          used:  16662 KB, available:   2417 KB, committed:  19412 KB
[41204:0x102001c00] Code space,         used:   4078 KB, available:    178 KB, committed:   5120 KB
[41204:0x102001c00] Map space,          used:    642 KB, available:      0 KB, committed:   2128 KB
[41204:0x102001c00] Large object space, used:      0 KB, available: 1434571 KB, committed:      0 KB
[41204:0x102001c00] All spaces,         used:  21552 KB, available: 1438005 KB, committed:  27684 KB
[41204:0x102001c00] External memory reported:   1026 KB
[41204:0x102001c00] Total time spent in GC  : 158.6 ms
[41204:0x102001c00] Memory reducer: call rate 0.003, low alloc, foreground
```
首先我们可以看到 Node.js 区分 New space、Old space 等来划分检索空间。而提示(+ 20.4 ms in 7 steps since start of marking, biggest step 4.8 ms) 告诉我们这个标记的步骤分 7 步进行，耗时最长的一次时 4.8ms。这使 JavaScript 可以很好的支持开发高实时应用。

总结
因为篇幅有限，留下一些小问题供大家思考：

- 闭包一定会导致内存不可被回收？  
- 如何监控一个 Node.js 服务的内存开销，如何处理不可预知的内存泄漏？

---

## this、apply、call、bind

### 隐式绑定的 this
this 实际上是在函数被调用时绑定的，它指向什么完全取决于函数的调用方式。
```js
var obj = {
  a: 1,
  foo: function () {
    console.log(this.a)
  }
}

var foo2 = obj.foo
obj.foo() // 1
foo2() // undefined
```

如果没有指定函数的运行对象，默认的 this 会隐式的绑定到运行环境的全局对象上。
```js
function foo() {
  console.log(this.a)
}
a = 'global'
foo() // global
```
看一个常见但是有点出乎意料的的例子，如果是回调函数，即使你传入了 obj.foo 还是会丢失 this。
```js
function foo() {
  console.log(this.a)
}
function doFoo(fn) {
  fn()
}
var obj = { a: 1, foo: foo }
a = "global"
doFoo(obj.foo) // global
```
如果是链式调用呢，则是最后哪个对象调用了这个方法，this 指向谁。
```js
function foo() {
  console.log(this.a);
}
var obj2 = { a: 11, foo: foo }
var obj1 = { a: 1, obj2: obj2 }
obj1.obj2.foo(); // 11
```
其实 this 的指向都有规律可言，在隐式绑定的 this 中，this 绑定的是调用它的对像。我们回过头解释上面例子。

第一个例子的 foo2() 和第二个例子的 foo() 其实是在 window (global) 对象上运行的，对应的打印值就合乎情理了。第三个例子涉及 JS 执行的原理，传入的 obj.foo 被赋值到 fn 上，所以本质上是 fn = obj.foo; window.fn()，因此 this 指向了 window 。

### 显式绑定的 this
隐式绑定的 this 能为我们带来很多灵活性，但是有时我们需要显式的指定函数运行的 this 。

比如 apply、call、bind 这三个绑定在 Function.prototype 上的函数（关于 prototype 我们会在后面的章节提到），让我们先看看具体 API。
```js
fun.apply(thisArg, [argsArray])
fun.call(thisArg, arg1, arg2, ...)
fun.bind(thisArg[, arg1[, arg2[, ...]]])
```
它们的语法十分相近，第一个参赛指定函数的 this 环境，后面的参赛指定函数需要的参数，最大的区别是 bind 不是执行 fun 而是返回一个函数，我们看看如何来用它们显式绑定 this。
```js
var obj1 = { a: 1 }
var obj2 = { a: 11 }
var foo = function () {
  console.log(this.a)
}
a = 'global'
foo.apply(obj1)     // 1
foo.call(obj2)      // 11
foo.bind(global)()  // global
```
实际情况 bind 更适合用来固定 this 环境。
```js
var obj1 = { a: 1 }
var obj2 = { a: 11 }
var foo = function () {
  console.log(this.a)
}.bind(obj1)
foo.apply(obj2)     // 1
foo.call(obj2)      // 1
```
另外我们还可以使用 new 和 => 尖头函数。

new 关键字把 this 指向实例，这个过程发生了什么，我们会在后面章节讨论。
```js
var foo = function (a) {
  this.a = a
}
foo.prototype.sayA = function () {
  console.log(this.a)
}
var bar = new foo(2)
foo.sayA() // 2
```
而尖头函数十分特别，你可以把它理解为 bind 函数的语法糖，它的 this 同外层函数的 this。
```js
var obj = {
  a: 1,
  foo: function () {
    console.log(this) 
    setTimeout(() => {
      console.log(this) 
    })
  }
}
obj.foo() // obj { a: 1, foo: ƒ }, obj { a: 1, foo: ƒ }
```

### 总结
this 是 JavaScript 的一大难点，多年经验的前端程序员都可能对这方面模糊。this 在大量的函数、类库中都有使用，理清显式绑定和隐式绑定有助于理解或书写这类函数。

---

## 递归、闭包、原型、继承
本文主要讲解、理清一些函数常用的知识点：递归、闭包是什么、闭包使用场景、什么是原型和原型链、如何实现继承、继承的原理。

### 递归
函数的递归就是在函数中调用自身

举一个实例，著名斐波那契数列如何求得，问题是这样的：

第一个月初有一对刚诞生的兔子
第二个月之后（第三个月初）它们可以生育
每月每对可生育的兔子会诞生下一对新兔子
兔子永不死去
定义出来的数列是



我们需要求得 n 月有多少对兔子，通过递归算法可以求得
```js
function fn(n) {
  return n < 2 ? 1 : fn(n - 1) + fn(n - 2)
}
var count = fn(30);
console.log(count);
```
### 闭包
什么是闭包？闭包就是函数，它可以继承并访问自身所被声明的函数作用域内的变量。
```js
function fn1 () {
  var a = 'hello'
  function fn2 () {
    console.log(a)
  }
}
fn1() // 其中 fn2 就是闭包函数
```
闭包的使用场景
闭包有很多使用场景，以下举例：

1. 私有变量
```js
function Person(){    
  var name = "default";       
  return {    
    getName : function(){    
      return name;    
    },    
      setName : function(newName){    
      name = newName;    
    }    
  }    
};
var person = Person()
console.log(person.getName()) // default
person.setName('xiaomuchen')
console.log(person.getName()) // xiaomuchen
var person2 = Person()
console.log(person2.getName()) // default
```
上述函数，使用闭包创建私有变量 name，变量不可被外部直接操作、获取，只能通过返回的接口控制。

2. 匿名自执行函数
比如在开发页面时，需要在页面初始化时，你需要立即做一些操作，那么可以在页面中使用匿名自执行函数，它会在 JS 引擎读取到这部分代码时就立即执行。
```js
// 在 title 上添加页面打开时间
(function(){
  var openTime = new Date()
  document.title = document.title + openTime
})();
```
### 原型、原型链、继承
先问一个问题：`__proto__` 和 prototype 会出现在什么地方？它们之间是什么关系？实现继承依赖什么？

#### `__proto__` 和 prototype 的区别
1.JavaScript 中每一个对象都拥有原型链（`__proto__`）指向其构造函数的原型（`prototype`）
```js
var a = {}
a.__proto__ === Object.prototype // true

function Person () {}
Person.__proto__ === Function.prototype // true

var p = new Person()
p.__proto__ === Person.prototype // true
```

2.JavaScript 中每一个函数都拥有原型（prototype），原型也是一个对象，这个对象包括：原型链、原型方法（属性）、函数构造，同理它的原型链指向其构造函数的原型
```js
function Person () {}
Person.prototype.getName = function () {}
Object.getOwnPropertyNames(Person.prototype) // ["constructor", "getName"]
Person.prototype.__proto__ === Object.prototype // true
```

3.当访问一个函数上的属性时，先尝试访问自身上的属性，再尝试访问其原型上的属性。当访问一个对象上的属性时，先尝试访问自身上的属性，再通过原型链尝试访问其构造函数原型上的属性。如果没有则通过原型上的原型链，继续向上查找，直到访问 `Object.prototype` 上的属性，如果还是没有，因为 `Object.prototype` 是一个没有 `__proto__`的对象，则查询到此为止，返回 undefined.
```js
function Person () {}
Person.getName = function () {
  console.log('Person1')
}
Person.prototype.getName = function () {
  console.log('Person2')
}
var p = new Person()

Person.getName() // Person1
p.getName() // Person2
console.log(typeof p.getClass) // undefined
```

#### 继承
JavaScript 函数通过原型和原型链实现继承
```js
function superA (name) {
  this.name = name
}
superA.prototype.getName = function () {
  console.log(this.name)
}
function subA (name) {
  superA.call(this, name) // 继承属性
}
subA.prototype = new superA() // 继承方法

var a1 = new subA('xiaomuchen')
a1.getName() // xiaomuchen
```

上述代码，描述了一个函数的经典继承，其工作原理是这样的：

声明父类 superA、子类 subA
重写子类 subA 的原型，指向 superA 的实例
当实例化 a1 时，`a1.__proto__ => subA.prototype => new superA() => superA.prototype`，所以 a1 的构造函数是 superA
同时，运行 subA 也就是 `superA.call(this, 'xiaomuchen')`，其中 this 指向 a1 所以 a1 继承了 name 属性
这样子类 subA 的实例 a1 就继承了 superA 的原型方法和属性

### 总结
本文概括了递归、闭包、原型、继承，理清这些基本的概念，有助于你接纳更多的东西，我们会在下一个章节对函数进行更深入的讨论。

---

## JavaScript 函数式编程

函数式编程是一种编程范式，记得在刚学编程时从面向过程编程 转换到 面向对象编程 时的触动，了解 函数式编程 或许会给你一个最初的惊喜。函数式编程是一个很大的命题，在本文中将介绍几个基本概念：纯函数、柯里化（curry）、组合（compose）、容器（container）、函子（functor），希望能激起你对它的兴趣。

### 如何实现链式调用
先让我们忘掉上面那些奇怪的概念，让我们看一个贯彻全文的实例，如何实现一个链式调用。
```js
var Container = function(x) {
  this.__value = x;
}

Container.of = function(x) { return new Container(x); };

Container.prototype.map = function(f){
  return Container.of(f(this.__value))
}
```
上述代码实现了一个简单的链式调用，让我们看看如何使用它
```js
Container.of(3); // Container {__value: 3}
Container.of(4); // Container {__value: 4}

var add1 = function (num) { return num + 1 };
var add2 = function (num) { return num + 2 };

Container.of(3).map(add1).map(add2) // Container {__value: 6}
Container.of(4).map(add2).map(add2).map(add2) // Container {__value: 10}
```
在这个实例中出现的 Container 是一个容器，通过 Container.of 来实例化保存值到 `this.__value 。add1、add2 都是 纯函数，我们通过 map 函数来操作容器内的值，我们把 Container 看作数据结构，这种数据结构可以通过 map 操作，那么它就叫 functor。

### 纯函数

> 什么是纯函数：纯函数是这样一种函数，即相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用。

比如 `slice` 和 `splice`，这两个函数的作用并别无二致。但是我们说 `slice` 符合纯函数的定义是因为对相同的输入它保证能返回相同的输出。而 splice 的调用却会产生可观察到的副作用，这个数组被永久地改变了。
```js
var xs = [1,2,3,4,5];

// 纯的
xs.slice(0,3); // => [1,2,3]
xs.slice(0,3); // => [1,2,3]

// 不纯的
xs.splice(0,3); // => [1,2,3]
xs.splice(0,3); // => [4,5]
```
在函数式编程中，我们尽量杜绝 splice 这种会改变数据的函数。我们追求的是 slice 那种可靠的，每次都能返回同样结果的函数。

再看另一个例子
```js
// 不纯的
var num_1 = 1
var add1 = function (num) { return num + num_1 };

// 纯的
var add1 = function (num) { return num + 1 };
```

在不纯的版本中，`add1` 的结果将取决于 `num_1` 这个可变变量的值。换句话说，它取决于`系统状态`（system state）。因为它引入了外部的环境，从而增加了`认知负荷`（cognitive load）。这种依赖状态是影响系统复杂度的罪魁祸首，不仅让它变得不纯，而且导致每次我们思考整个软件的时候都痛苦不堪。

为什么要使用纯函数呢？举例容易看到的好处：1. 可缓存性，因为纯函数对于相同的输入有相同的输出，所以纯函数是可以缓存运算结果的；2. 可移植性，因为不会受环境变量等外部状态的影响，可以方便移植；3. 可测试性，无需配置外部变量，一个输入一个输出，直接断言；等等。

有哪些不纯的情况呢？1. IO 操作，你不知道你读取的内容会是怎样；2. 接口请求，你确定返回的内容是什么；3. dom 操作，引起了副作用；4. 甚至连 console.log 都是不纯的，因为它有副作用；等等。对于不纯的函数我们尽量把它控制在可控范围内发生，这个会在文章后面提到。

### 函数柯里化
什么是柯里化（curry）？curry 的概念很简单，只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数

简单的实例：
```js
var add = function (x, y) {  return x + y; }
add(1, 2)   // 3
add(10, 1)  // 11
add(10, 2)  // 12
add(10, 3)  // 13

// curry
var add = function(x) {
  return function(y) {
    return x + y;
  };
};

var increment = add(1);
var addTen = add(10);

increment(2); // 3
addTen(1); // 11
addTen(2); // 12
addTen(3); // 13
```

我们把 add 函数通过柯里化变成了接受部分参数并返回一个处理剩余函数且返回结果的函数。在实际环境中我们可能用到 ramda 这样的库来帮助我们实现柯里化。
```js
var R = require('ramda');
var add = function (x, y) { return x + y; }
var addTen = R.curry(add)(10)

addTen(1); // 11
addTen(2); // 12
```
柯里化是函数式编程的工具，他能实现预加载函数、分步取值、避免重复传参、锁定函数运行环境等等功能。

### 函数组合
这就是组合（compose）
```js
// 简单实现，复杂实现可以传递多个函数用于组合
var compose = function(f,g) {
  return function(x) {
    return f(g(x));
  };
};
```
组合多个函数生成一个新的函数，并且函数从右往左运行。
```js
var double = function (num) { return num * 2 }
var add =  R.curry(function (x, y) { return x + y; })

var price = compose(double, add(10)) // 通过成本获取商品价格

price(10) // 40
price(20) // 60
```
通过函数组合我们可以，一次性的合并多个处理函数，并且可以方便的改变函数的执行顺序。

### 容器和函子（functor）
让我们回顾开头的例子
```js
var Container = function(x) {
  this.__value = x;
}

Container.of = function(x) { return new Container(x); };

Container.prototype.map = function(f){
  return Container.of(f(this.__value))
}
```
现在我们转换角度，把调用 `Container.of` 返回的对象看作一种数据结构 `Container {__value: 3}` ，这种数据结构只能使用 `map` 方法进行操作，类似这样的数据结构被称为 `functor`。

这样做的好处是什么呢？我们能在不离开 容器（Container） 的情况下操作容器里面的值，操作完成之后又放回容器。我们可以不断的进行这一操作，就像 组合函数 一样。这是一种抽象，我们让容器保存值，并且请求容器通过 map 里的函数去操作值。

总结
在文章中，提到了 纯函数、柯里化（curry）、组合（compose）、容器（container）、函子（functor），不要看它们很遥远其实已经或多或少出现在我们身边。举个例子：尖头函数。
```js
const curryAdd = x => y => x + y
const compose = (f, g) => x => f(g(x))
const double = num => num * 2
const price = y => compose(double, curryAdd(10))(y)

console.log(price(0)) // 20
```
仅仅几行代码就可以体验 `curry` 和 `compose` 工具，如果在阅读本文之后对这种编程范式感兴趣的的话，或者对 不纯操作的处理、处理错误和流程 等延伸内容好奇的话，可以阅读这篇文章《JS 函数式编程指南》。

---

## JavaScript 异步流程控制
本文主要讲解 JavaScript 在异步流程控制中的一些实践、容错以及复杂异步环境下我们该如何去处理。

### 发展历史
简要的提及一下，异步流程控制的发展历史大概是`callback hell => Promise => Generator => async/await`

ES6 中 Promise 是通过 `.then().then().catch()` 的方式来解决 callback 多层嵌套的问题。但 Promise 依然是异步执行的，这时候 TJ 的 co，通过 `Generator` 实现了异步代码的同步化。这个模式和 ES7 中的 `async/await` 类似。
```js
function A() {
  // async get dataA
  function B(dataA) {
    // async get dataB
    function C(dataB) {
    }
  }
}

Promise(A).then(B).then(C).catch(err => console.log(err))

co(function *() {
  var dataA = yield A()
  var dataB = yield B(dataA)
  var dataC = yield C(dataB)
})

async () => {
  const dataA = await A()
  const dataB = await B(dataA)
  const dataC = await C(dataB)
}
```
### 使用
首先是语法糖支持情况，你可以使用下面命令行查看当前 node 版本对于 ES6/ES7 的支持。目前大多浏览器是不支持新语法的，如果你当前环境不支持新语法，你可以使用 bable、 co、 Promise、 bluebird 等开源项目来扩展功能。

```js
$ node --v8-options | grep harmony
```

对了如果你还对这些新语法的使用方式和 API 陌生的话，建议看看 《ECMAScript 6 入门》 这本书，下面的内容，假定你对基本的使用已经有所了解，我们开始正篇。

### Promise 实践和容错
之前当面试官的时候，如果面试对象经常使用 ES6，我会喜欢问一个问题：假设你的移动端页面上有头部、中部、底部三部分数据需要并发的去请求 api 拿到返回数据，你会怎么处理？用 Promise 如何实现？如果其中一个 API 出了错误怎么容错？

1.第一个问题很简单，依次执行三个异步请求函数，在获取到数据后执行渲染函数填充到页面上

2.第二个问题，其实也没多绕，你可以同时执行三个 Promise 函数，也可以打包成 `Promise.all()` 一并执行，显然对于这种并发执行的异步函数 `Promise.all()` 更符合程序设计。
```js
const render = log = console.log
const asyncApi = (num) => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (typeof num !== 'number') {
        reject('param error')
      }
      num += 10
      resolve(num)
    }, 100);
  })
}

asyncApi(0).then(render).catch(log)  // 10
asyncApi(5).then(render).catch(log)  // 15
asyncApi(10).then(render).catch(log) // 20

Promise.all([asyncApi(0), asyncApi(5), asyncApi(10)]).then(render).catch(log) // [ 10, 15, 20 ]
```
3.无论怎样，我会把面试者引导到 `Promise.all()` 上，这时候我会抛出问题 如果其中一个 API 出了错误怎么容错？
```js
asyncApi(0).then(render).catch(log)       // 10
asyncApi(false).then(render).catch(log)   // param error
asyncApi(10).then(render).catch(log)      // 20

Promise.all([asyncApi(0), asyncApi(false), asyncApi(10)]).then(render).catch(log) // param error
```
对比发现，Promise 之间互不影响。但由于 `Promise.all()` 其实是将传入的多个 `Promise` 打包成一个，任何一个地方出错了都会直接抛出异常，导致不执行 `then` 直接跳到了 `catch`，丢失了成功的数据。

4.解决方式是使用 resolve 传递错误，then 环节去处理
```js
const render = log = console.log
const asyncApi = (num) => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (typeof num !== 'number') {
        resolve({ err: 'param error' }) // 修改前：reject('param error')
      }
      num += 10
      resolve({ data: num }) // 修改前：resolve(num)
    }, 100);
  })
}

Promise.all([asyncApi(0), asyncApi(false), asyncApi(10)]).then(render).catch(log) 
// [ { data: 10 }, { err: 'param error' }, { data: 20 } ]，这时候就可以区分处理了
```
### 复杂环境
我们假设一个如下的复杂场景，异步请求之间相互依赖。仅仅用 `Promise` 来实现，会不停的调用 `then、` `return` 并且创建匿名函数。
```js
// 流程示意图
//          data            data1
// asyncApi -----> asyncApi -----> render/error
//     10 + data            data2           data3
//          -----> asyncApi -----> asyncApi -----> render/error

asyncApi(0).then(data => {
  return Promise.all([asyncApi(data.data), asyncApi(10 + data.data)])
}).then(([data1, data2]) => {
  render(data1)
  return asyncApi(data2.data)
}).then(render).catch(log)
```
而如果加上 `async/await` 来改写它，就可以完全按同步的写法来获取异步数据，并且语义清晰。
```js
const run = async () => {
  let data = await asyncApi(0)
  let [data1, data2] = await Promise.all([asyncApi(data.data), asyncApi(10 + data.data)])
  render(data1)
  let data3 = await asyncApi(data2.data)
  render(data3)
}
run().catch(log)
```
或许你觉得差不了太多，那我再改一下，现在我们看到 data3 是需要 data2 作为函数参数才能获取，假如：获取 data3 需要 data 和 data2 呢？

你会发现 Promise 的写法隔离了环境，如果需要 data 这个值，那就要想办法传递下去或保存到其他地方，而 `async/await` 的写法就不需要考虑这个问题。

### 总结
在本文的前半部分简单介绍了流程控制的发展历史和如何使用这些新的语法糖，后半部分我们聊到了 `Promise` 和 `async/await` 如何去实现复杂的异步流程环境，并满足容错和可读性。

做一个有追求的程序员，在实际项目中多去思考容错和可读性，相信代码质量会有不错的提升。

---

